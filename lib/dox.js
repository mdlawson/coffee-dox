// Generated by CoffeeScript 1.3.3
var codePack, codeUnpack, escape, highlightCode, marked, parseIndent, spawn, trimCode;

marked = require("marked");

escape = require("./utils").escape;

spawn = require("child_process").spawn;

exports.version = "0.3.1";

exports.parseComments = function(coffee, options, callback) {
  var buf, code, codeBuf, comment, commentBuf, comments, escaped, highlight, highlighted, i, indent, j, len, parent, prevComment, raw, withinMultiline, withinSingle;
  options = options || {};
  coffee = coffee.replace(/\r\n/g, "\n");
  coffee = coffee.replace(/\t/g, "  ");
  comments = [];
  highlighted = [];
  raw = options.raw;
  highlight = options.highlight;
  comment = void 0;
  prevComment = void 0;
  buf = "";
  codeBuf = "";
  commentBuf = "";
  escaped = false;
  withinMultiline = false;
  withinSingle = false;
  indent = 0;
  code = void 0;
  i = 0;
  len = coffee.length;
  while (i < len) {
    if (coffee[i - 1] === "\n") {
      j = i;
      indent = 0;
      while (coffee[j] === " ") {
        indent++;
        j++;
      }
    }
    if (!withinMultiline && !withinSingle && "#" === coffee[i]) {
      withinSingle = true;
      buf += coffee[i];
    } else if (!withinMultiline && withinSingle && "\n" === coffee[i] && "#" === coffee[i + 1 + indent]) {
      buf += coffee[i];
      commentBuf += buf;
      buf = "";
      if (codeBuf.trim().length) {
        if (prevComment) {
          prevComment.code = trimCode(codeBuf, prevComment.indent);
          prevComment.ctx = exports.parseCodeContext(prevComment.code, prevComment.parent);
        }
        codeBuf = "";
      }
      withinSingle = false;
      withinMultiline = true;
    } else if (withinMultiline && !withinSingle && "\n" === coffee[i] && "#" !== coffee[i + 1 + indent]) {
      commentBuf = commentBuf.replace(/^ *# ?/gm, "");
      comment = exports.parseComment(commentBuf, options);
      comment.indent = indent;
      parent = prevComment || {
        indent: -1,
        children: comments
      };
      while (comment.parent == null) {
        if (parent.indent < comment.indent) {
          comment.parent = parent;
          comment.parent.children.push(comment);
        } else {
          parent = parent.parent || {
            indent: -1,
            children: comments
          };
        }
      }
      withinMultiline = false;
      commentBuf = "";
      prevComment = comment;
    } else if (withinSingle && !withinMultiline && "\n" === coffee[i]) {
      withinSingle = false;
      buf += coffee[i];
      codeBuf += buf;
      buf = "";
    } else {
      if (withinSingle) {
        buf += coffee[i];
      } else if (withinMultiline) {
        commentBuf += coffee[i];
      } else {
        codeBuf += coffee[i];
      }
    }
    ++i;
  }
  if (comments.length === 0) {
    comments.push({
      tags: [],
      description: {
        full: "Nothing to see here...",
        summary: "",
        body: ""
      },
      children: [],
      isPrivate: false
    });
  }
  if (codeBuf.trim().length) {
    if (prevComment) {
      prevComment.code = trimCode(codeBuf, prevComment.indent);
      prevComment.ctx = exports.parseCodeContext(prevComment.code, prevComment.parent);
    }
  }
  if (highlight) {
    return highlightCode(comments, callback);
  } else {
    return callback(comments);
  }
};

trimCode = function(code, indent) {
  var k, lines, result;
  lines = code.split("\n");
  result = lines[0].slice(indent);
  k = 1;
  while (k < lines.length) {
    if (parseIndent(lines[k]) <= indent) {
      break;
    }
    result += "\n" + lines[k].slice(indent);
    k++;
  }
  return result;
};

parseIndent = function(string) {
  var idt;
  idt = 0;
  while (string[idt] === " ") {
    idt++;
  }
  return idt;
};

highlightCode = function(comments, cb) {
  var output, pyg;
  pyg = spawn('pygmentize', ['-l', 'coffee-script', '-f', 'html', '-O', 'encoding=utf-8,tabsize=2']);
  output = '';
  pyg.stderr.on('data', function(error) {
    if (error) {
      return console.error(error.toString());
    }
  });
  pyg.stdin.on('error', function(error) {
    console.error("could not use pygments to highlight the source");
    return output = code;
  });
  pyg.stdout.on('data', function(result) {
    if (result) {
      return output += result;
    }
  });
  pyg.on('exit', function() {
    var el, html;
    output = output.replace('<div class="highlight"><pre>', '').replace('</pre></div>', '').replace(/\r\n/g, "\n");
    html = output.split(/<span class="c1">#DELIM#<\/span>\n/);
    html = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = html.length; _i < _len; _i++) {
        el = html[_i];
        if (el) {
          _results.push(el);
        }
      }
      return _results;
    })();
    comments = codeUnpack(comments, html);
    return cb(comments);
  });
  if (pyg.stdin.writable) {
    pyg.stdin.write(codePack(comments));
    return pyg.stdin.end();
  }
};

codePack = function(root) {
  var child, code, _i, _len;
  code = '';
  for (_i = 0, _len = root.length; _i < _len; _i++) {
    child = root[_i];
    if (child.code) {
      code += child.code + "#DELIM#\n";
    }
    if (child.children.length) {
      code += codePack(child.children) + "#DELIM#\n";
    }
  }
  return code;
};

codeUnpack = function(root, code) {
  var child, _i, _len;
  for (_i = 0, _len = root.length; _i < _len; _i++) {
    child = root[_i];
    if (child.code) {
      child.code = code.shift();
    }
    if (child.children.length) {
      child.children = codeUnpack(child.children, code);
    }
  }
  return root;
};

exports.parseComment = function(str, options) {
  var comment, description, param, raw, tag, tags, _i, _len, _ref, _ref1;
  str = str.trim();
  options = options || {};
  comment = {
    tags: [],
    children: []
  };
  raw = options.raw;
  description = {};
  description.full = str.split("\n@")[0].replace(/^([A-Z][\w ]+):$/g, "## $1");
  description.summary = description.full.split("\n\n")[0];
  description.body = description.full.split("\n\n").slice(1).join("\n\n");
  comment.description = description;
  if (~str.indexOf("\n@")) {
    tags = "@" + str.split("\n@").slice(1).join("\n@");
    comment.tags = tags.split("\n").map(exports.parseTag);
    param = {};
    _ref = comment.tags;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      tag = _ref[_i];
      if (tag.type === "param") {
        param = tag;
      } else if (tag.type === "option") {
        if ((_ref1 = param.options) == null) {
          param.options = [];
        }
        param.options.push(tag);
      }
    }
    comment.tags = (function() {
      var _j, _len1, _ref2, _results;
      _ref2 = comment.tags;
      _results = [];
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        tag = _ref2[_j];
        if (tag.type !== "option") {
          _results.push(tag);
        }
      }
      return _results;
    })();
    comment.isPrivate = comment.tags.some(function(tag) {
      return "api" === tag.type && "private" === tag.visibility;
    });
  }
  if (!raw) {
    description.full = marked(description.full);
    description.summary = marked(description.summary);
    description.body = marked(description.body);
  }
  return comment;
};

exports.parseTag = function(str) {
  var parts, tag, type;
  tag = {};
  parts = str.split(RegExp(" +"));
  type = tag.type = parts.shift().replace("@", "");
  switch (type) {
    case "param":
      tag.types = exports.parseTagTypes(parts.shift());
      tag.name = parts.shift() || "";
      tag.description = parts.join(" ");
      break;
    case "option":
      tag.types = exports.parseTagTypes(parts.shift());
      tag.name = parts.shift();
      tag.description = parts.join(" ");
      break;
    case "return":
      tag.types = exports.parseTagTypes(parts.shift());
      tag.description = parts.join(" ");
      break;
    case "see":
      if (~str.indexOf("http")) {
        tag.title = (parts.length > 1 ? parts.shift() : "");
        tag.url = parts.join(" ");
      } else {
        tag.local = parts.join(" ");
      }
      break;
    case "api":
      tag.visibility = parts.shift();
      break;
    case "type":
      tag.types = exports.parseTagTypes(parts.shift());
      break;
    case "memberOf":
      tag.parent = parts.shift();
      break;
    case "augments":
      tag.otherClass = parts.shift();
      break;
    case "borrows":
      tag.otherMemberName = parts.join(" ").split(" as ")[0];
      tag.thisMemberName = parts.join(" ").split(" as ")[1];
      break;
    default:
      tag.string = parts.join(" ");
  }
  return tag;
};

exports.parseTagTypes = function(str) {
  return str.replace(/[{}]/g, "").split(RegExp(" *[|,\\/] *"));
};

exports.parseCodeContext = function(str, parent) {
  str = str.split("\n")[0];
  if (/^class *([^\n; ]+)/.exec(str)) {
    return {
      type: "class",
      name: RegExp.$1,
      string: "class " + RegExp.$1
    };
  } else if (/^(\w+) *= *(\(.*\)|) *->/.exec(str)) {
    return {
      type: "function",
      name: RegExp.$1,
      string: RegExp.$1 + "()"
    };
  } else if (/^(\w+)::(\w+) *= *(\(.*\)|) *->/.exec(str)) {
    return {
      type: "method",
      constructor: RegExp.$1,
      name: RegExp.$2,
      string: RegExp.$1 + ".prototype." + RegExp.$2 + "()"
    };
  } else if (/^(\w+)::(\w+) *= *([^\n;]+)/.exec(str)) {
    return {
      type: "property",
      constructor: RegExp.$1,
      name: RegExp.$2,
      value: RegExp.$3,
      string: RegExp.$1 + ".prototype" + RegExp.$2
    };
  } else if (/^(\w+)\.(\w+) *= *(\(.*\)|) *->/.exec(str) || /^@(\w+)\.?(\w+) *= *(\(.*\)|) *->/.exec(str)) {
    return {
      type: "method",
      receiver: RegExp.$1,
      name: RegExp.$2,
      string: RegExp.$1 + "." + RegExp.$2 + "()"
    };
  } else if (/^(\w+): *(\(.*\)|) *->/.exec(str)) {
    return {
      type: "method",
      receiver: parent.ctx.name,
      name: RegExp.$1,
      string: RegExp.$1 + "()"
    };
  } else if (/^(\w+)\.(\w+) *= *([^\n;]+)/.exec(str) || /^@(\w+)\.?(\w+) *= *([^\n;]+)/.exec(str)) {
    return {
      type: "property",
      receiver: RegExp.$1,
      name: RegExp.$2,
      value: RegExp.$3,
      string: RegExp.$1 + "." + RegExp.$2
    };
  } else if (/^(\w+): *([^\n;]+)/.exec(str)) {
    return {
      type: "property",
      receiver: parent.ctx.name,
      name: RegExp.$1,
      value: RegExp.$2,
      string: RegExp.$1
    };
  } else if (/^(\w+) *= *([^\n;]+)/.exec(str)) {
    return {
      type: "declaration",
      name: RegExp.$1,
      value: RegExp.$2,
      string: RegExp.$1
    };
  } else {
    return {
      type: "",
      name: "",
      value: "",
      string: ""
    };
  }
};
