// Generated by CoffeeScript 1.3.3
var escape, markdown, parseIndent, trimCode;

markdown = require("github-flavored-markdown").parse;

escape = require("./utils").escape;

exports.version = "0.3.1";

exports.parseComments = function(coffee, options) {
  var buf, code, codeBuf, comment, commentBuf, comments, escaped, i, indent, j, len, parent, prevComment, raw, withinMultiline, withinSingle;
  options = options || {};
  coffee = coffee.replace(/\r\n/g, "\n");
  coffee = coffee.replace(/\t/g, "  ");
  comments = [];
  raw = options.raw;
  comment = void 0;
  prevComment = void 0;
  buf = "";
  codeBuf = "";
  commentBuf = "";
  escaped = false;
  withinMultiline = false;
  withinSingle = false;
  indent = 0;
  code = void 0;
  i = 0;
  len = coffee.length;
  while (i < len) {
    if (coffee[i - 1] === "\n") {
      j = i;
      indent = 0;
      while (coffee[j] === " ") {
        indent++;
        j++;
      }
    }
    if (coffee[i] === escaped) {
      escaped = false;
    } else if (coffee[i] === '"' || coffee[i] === "'" || coffee[i] === '`') {
      escaped = coffee[i];
    }
    if (!withinMultiline && !withinSingle && "#" === coffee[i] && !escaped) {
      withinSingle = true;
      buf += coffee[i];
    } else if (!withinMultiline && withinSingle && "\n" === coffee[i] && "#" === coffee[i + 1 + indent] && !escaped) {
      buf += coffee[i];
      commentBuf += buf;
      buf = "";
      if (codeBuf.trim().length) {
        if (prevComment) {
          prevComment.code = trimCode(codeBuf, prevComment.indent);
          prevComment.ctx = exports.parseCodeContext(prevComment.code);
        }
        codeBuf = "";
      }
      withinSingle = false;
      withinMultiline = true;
    } else if (withinMultiline && !withinSingle && "\n" === coffee[i] && "#" !== coffee[i + 1 + indent] && !escaped) {
      commentBuf = commentBuf.replace(/^ *# ?/gm, "");
      comment = exports.parseComment(commentBuf, options);
      comment.indent = indent;
      parent = prevComment || {
        indent: -1,
        children: comments
      };
      while (comment.parent == null) {
        if (parent.indent < comment.indent) {
          comment.parent = parent;
          comment.parent.children.push(comment);
        } else {
          parent = parent.parent || {
            indent: -1,
            children: comments
          };
        }
      }
      withinMultiline = false;
      commentBuf = "";
      prevComment = comment;
    } else if (withinSingle && !withinMultiline && "\n" === coffee[i] && !escaped) {
      withinSingle = false;
      buf += coffee[i];
      codeBuf += buf;
      buf = "";
    } else {
      if (withinSingle) {
        buf += coffee[i];
      } else if (withinMultiline) {
        commentBuf += coffee[i];
      } else {
        codeBuf += coffee[i];
      }
    }
    ++i;
  }
  if (comments.length === 0) {
    comments.push({
      tags: [],
      description: {
        full: "",
        summary: "",
        body: ""
      },
      children: [],
      isPrivate: false
    });
  }
  if (codeBuf.trim().length) {
    if (prevComment) {
      prevComment.code = trimCode(codeBuf, prevComment.indent);
      prevComment.ctx = exports.parseCodeContext(prevComment.code);
    }
  }
  return comments;
};

trimCode = function(code, indent) {
  var k, lines, result;
  lines = code.split("\n");
  result = lines[0].slice(indent) + "\n";
  k = 1;
  while (k < lines.length) {
    if (parseIndent(lines[k]) <= indent) {
      break;
    }
    result += lines[k].slice(indent) + "\n";
    k++;
  }
  return result;
};

parseIndent = function(string) {
  var idt;
  idt = 0;
  while (string[idt] === " ") {
    idt++;
  }
  return idt;
};

exports.parseComment = function(str, options) {
  var comment, description, raw, tags;
  str = str.trim();
  options = options || {};
  comment = {
    tags: [],
    children: []
  };
  raw = options.raw;
  description = {};
  description.full = str.split("\n@")[0].replace(/^([A-Z][\w ]+):$/g, "## $1");
  description.summary = description.full.split("\n\n")[0];
  description.body = description.full.split("\n\n").slice(1).join("\n\n");
  comment.description = description;
  if (~str.indexOf("\n@")) {
    tags = "@" + str.split("\n@").slice(1).join("\n@");
    comment.tags = tags.split("\n").map(exports.parseTag);
    comment.isPrivate = comment.tags.some(function(tag) {
      return "api" === tag.type && "private" === tag.visibility;
    });
  }
  if (!raw) {
    description.full = markdown(description.full);
    description.summary = markdown(description.summary);
    description.body = markdown(description.body);
  }
  return comment;
};

exports.parseTag = function(str) {
  var parts, tag, type;
  tag = {};
  parts = str.split(RegExp(" +"));
  type = tag.type = parts.shift().replace("@", "");
  switch (type) {
    case "param":
      tag.types = exports.parseTagTypes(parts.shift());
      tag.name = parts.shift() || "";
      tag.description = parts.join(" ");
      break;
    case "option":
      tag.object = parts.shift();
      tag.types = exports.parseTagTypes(parts.shift());
      tag.name = parts.shift();
      tag.description = parts.join(" ");
      break;
    case "return":
      tag.types = exports.parseTagTypes(parts.shift());
      tag.description = parts.join(" ");
      break;
    case "see":
      if (~str.indexOf("http")) {
        tag.title = (parts.length > 1 ? parts.shift() : "");
        tag.url = parts.join(" ");
      } else {
        tag.local = parts.join(" ");
      }
      break;
    case "api":
      tag.visibility = parts.shift();
      break;
    case "type":
      tag.types = exports.parseTagTypes(parts.shift());
      break;
    case "memberOf":
      tag.parent = parts.shift();
      break;
    case "augments":
      tag.otherClass = parts.shift();
      break;
    case "borrows":
      tag.otherMemberName = parts.join(" ").split(" as ")[0];
      tag.thisMemberName = parts.join(" ").split(" as ")[1];
      break;
    default:
      tag.string = parts.join(" ");
  }
  return tag;
};

exports.parseTagTypes = function(str) {
  return str.replace(/[{}]/g, "").split(RegExp(" *[|,\\/] *"));
};

exports.parseCodeContext = function(str) {
  str = str.split("\n")[0];
  if (/^class *(\w+)/.exec(str)) {
    return {
      type: "class",
      name: RegExp.$1,
      string: "class " + RegExp.$1
    };
  } else if (/^(\w+) *= *(\(.*\)|) *->/.exec(str)) {
    return {
      type: "function",
      name: RegExp.$1,
      string: RegExp.$1 + "()"
    };
  } else if (/^(\w+)::(\w+) *= *(\(.*\)|) *->/.exec(str)) {
    return {
      type: "method",
      constructor: RegExp.$1,
      name: RegExp.$2,
      string: RegExp.$1 + ".prototype." + RegExp.$2 + "()"
    };
  } else if (/^(\w+)::(\w+) *= *([^\n;]+)/.exec(str)) {
    return {
      type: "property",
      constructor: RegExp.$1,
      name: RegExp.$2,
      value: RegExp.$3,
      string: RegExp.$1 + ".prototype" + RegExp.$2
    };
  } else if (/^(\w+)\.(\w+) *= *(\(.*\)|) *->/.exec(str) || /^@(\w+)\.?(\w+) *= *(\(.*\)|) *->/.exec(str)) {
    return {
      type: "method",
      receiver: RegExp.$1,
      name: RegExp.$2,
      string: RegExp.$1 + "." + RegExp.$2 + "()"
    };
  } else if (/^(\w+): *(\(.*\)|) *->/.exec(str)) {
    return {
      type: "method",
      receiver: void 0,
      name: RegExp.$1,
      string: RegExp.$1 + "()"
    };
  } else if (/^(\w+)\.(\w+) *= *([^\n;]+)/.exec(str) || /^@(\w+)\.?(\w+) *= *([^\n;]+)/.exec(str)) {
    return {
      type: "property",
      receiver: RegExp.$1,
      name: RegExp.$2,
      value: RegExp.$3,
      string: RegExp.$1 + "." + RegExp.$2
    };
  } else if (/^(\w+): *([^\n;]+)/.exec(str)) {
    return {
      type: "property",
      receiver: void 0,
      name: RegExp.$1,
      value: RegExp.$2,
      string: RegExp.$1
    };
  } else if (/^(\w+) *= *([^\n;]+)/.exec(str)) {
    return {
      type: "declaration",
      name: RegExp.$1,
      value: RegExp.$2,
      string: RegExp.$1
    };
  }
};
