// Generated by CoffeeScript 1.3.3
var escape, markdown;

markdown = require("github-flavored-markdown").parse;

escape = require("./utils").escape;

exports.version = "0.3.1";

exports.parseComments = function(coffee, options) {
  var buf, code, comment, comments, i, ignore, indent, j, len, prevIndent, raw, withinMultiline, withinSingle;
  options = options || {};
  coffee = coffee.replace(/\r\n/g, "\n");
  comments = [];
  raw = options.raw;
  comment = void 0;
  buf = "";
  ignore = void 0;
  withinMultiline = false;
  withinSingle = false;
  prevIndent = 0;
  indent = 0;
  code = void 0;
  i = 0;
  len = coffee.length;
  while (i < len) {
    if (coffee[i - 1] === "\n") {
      j = i;
      indent = 0;
      while (coffee[j] === " " || coffee[j] === "\t") {
        indent++;
        j++;
      }
    }
    if (!withinMultiline && !withinSingle && "#" === coffee[i]) {
      withinSingle = true;
      buf += coffee[i];
    } else if (withinMultiline && !withinSingle && "\n" === coffee[i] && "#" !== coffee[i + 1 + indent]) {
      buf = buf.replace(/^ *# ?/gm, "");
      comment = exports.parseComment(buf, options);
      comment.ignore = ignore;
      comments.push(comment);
      withinMultiline = ignore = false;
      buf = "";
    } else if (withinSingle && !withinMultiline && "\n" === coffee[i] && "#" === coffee[i + 1 + indent]) {
      i++;
      if (buf.trim().length) {
        comment = comments[comments.length - 1];
        if (comment) {
          comment.code = code = buf.trim();
          comment.ctx = exports.parseCodeContext(code);
        }
        buf = "";
      }
      withinSingle = false;
      withinMultiline = true;
    } else if (withinSingle && !withinMultiline && "\n" === coffee[i]) {
      withinSingle = false;
      buf += coffee[i];
    } else {
      buf += coffee[i];
    }
    ++i;
  }
  if (comments.length === 0) {
    comments.push({
      tags: [],
      description: {
        full: "",
        summary: "",
        body: ""
      },
      isPrivate: false
    });
  }
  if (buf.trim().length) {
    comment = comments[comments.length - 1];
    code = buf.trim();
    comment.code = code;
    comment.ctx = exports.parseCodeContext(code);
  }
  return comments;
};

exports.parseComment = function(str, options) {
  var comment, description, raw, tags;
  str = str.trim();
  options = options || {};
  comment = {
    tags: []
  };
  raw = options.raw;
  description = {};
  description.full = str.split("\n@")[0].replace(/^([A-Z][\w ]+):$/g, "## $1");
  description.summary = description.full.split("\n\n")[0];
  description.body = description.full.split("\n\n").slice(1).join("\n\n");
  comment.description = description;
  if (~str.indexOf("\n@")) {
    tags = "@" + str.split("\n@").slice(1).join("\n@");
    comment.tags = tags.split("\n").map(exports.parseTag);
    comment.isPrivate = comment.tags.some(function(tag) {
      return "api" === tag.type && "private" === tag.visibility;
    });
  }
  if (!raw) {
    description.full = markdown(description.full);
    description.summary = markdown(description.summary);
    description.body = markdown(description.body);
  }
  return comment;
};

exports.parseTag = function(str) {
  var parts, tag, type;
  tag = {};
  parts = str.split(RegExp(" +"));
  type = tag.type = parts.shift().replace("@", "");
  switch (type) {
    case "param":
      tag.types = exports.parseTagTypes(parts.shift());
      tag.name = parts.shift() || "";
      tag.description = parts.join(" ");
      break;
    case "return":
      tag.types = exports.parseTagTypes(parts.shift());
      tag.description = parts.join(" ");
      break;
    case "see":
      if (~str.indexOf("http")) {
        tag.title = (parts.length > 1 ? parts.shift() : "");
        tag.url = parts.join(" ");
      } else {
        tag.local = parts.join(" ");
      }
      break;
    case "api":
      tag.visibility = parts.shift();
      break;
    case "type":
      tag.types = exports.parseTagTypes(parts.shift());
      break;
    case "memberOf":
      tag.parent = parts.shift();
      break;
    case "augments":
      tag.otherClass = parts.shift();
      break;
    case "borrows":
      tag.otherMemberName = parts.join(" ").split(" as ")[0];
      tag.thisMemberName = parts.join(" ").split(" as ")[1];
      break;
    default:
      tag.string = parts.join(" ");
  }
  return tag;
};

exports.parseTagTypes = function(str) {
  return str.replace(/[{}]/g, "").split(RegExp(" *[|,\\/] *"));
};

exports.parseCodeContext = function(str) {
  str = str.split("\n")[0];
  if (/^(\w+) *= *(\(.*\)|) *->/.exec(str)) {
    return {
      type: "function",
      name: RegExp.$1,
      string: RegExp.$1 + "()"
    };
  } else if (/^(\w+)::(\w+) *= *(\(.*\)|) *->/.exec(str)) {
    return {
      type: "method",
      constructor: RegExp.$1,
      name: RegExp.$2,
      string: RegExp.$1 + ".prototype." + RegExp.$2 + "()"
    };
  } else if (/(\w+)::(\w+) *= *([^\n;]+)/.exec(str)) {
    return {
      type: "property",
      constructor: RegExp.$1,
      name: RegExp.$2,
      value: RegExp.$3,
      string: RegExp.$1 + ".prototype" + RegExp.$2
    };
  } else if (/^(@|\w+.\.)*(\w+) *= *(\(.*\)|) *->/.exec(str)) {
    return {
      type: "method",
      receiver: RegExp.$1,
      name: RegExp.$2,
      string: RegExp.$1 + "." + RegExp.$2 + "()"
    };
  } else if (/^(@|\w+.\.)*(\w+) *= *([^\n;]+)/.exec(str)) {
    return {
      type: "property",
      receiver: RegExp.$1,
      name: RegExp.$2,
      value: RegExp.$3,
      string: RegExp.$1 + "." + RegExp.$2
    };
  } else if (/^(\w+) *= *([^\n;]+)/.exec(str)) {
    return {
      type: "declaration",
      name: RegExp.$1,
      value: RegExp.$2,
      string: RegExp.$1
    };
  }
};
